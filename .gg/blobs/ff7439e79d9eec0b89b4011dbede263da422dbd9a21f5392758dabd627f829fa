import re
from typing import Any, Optional, Tuple

def find_block_range(lines: list[str], block_name: str) -> Optional[Tuple[int, int]]:
    """lines 리스트에서 block_name { ... } 블록의 시작/끝 인덱스를 찾음."""
    n = len(lines)
    start = None
    for i, line in enumerate(lines):
        if re.match(rf'^\s*{re.escape(block_name)}\b', line.strip()):
            start = i
            break
    if start is None:
        return None

    i = start + 1
    if i >= n or not lines[i].strip().startswith('{'):
        return None

    brace_level = 0
    for j in range(i, n):
        brace_level += lines[j].count('{')
        brace_level -= lines[j].count('}')
        if brace_level == 0:
            return start, j
    return None

def detect_value_column(line: str) -> Optional[int]:
    """'    field           p;' 에서 'p'가 시작하는 컬럼(0-based)을 반환."""
    if not line.strip():
        return None
    if line.strip().startswith('//'):
        return None
    if line.strip() == '}':
        return None

    leading = len(line) - len(line.lstrip(' '))
    tokens = line.strip().split()
    if len(tokens) < 2:
        return None

    key_token = tokens[0]
    key_index = line.find(key_token, leading)
    if key_index == -1:
        return None

    i = key_index + len(key_token)
    while i < len(line) and line[i] == ' ':
        i += 1
    if i >= len(line):
        return None
    return i

def build_key_value_line(base_indent: str, new_key: str, val_str: str, value_col: Optional[int]) -> str:
    """들여쓰기/값 컬럼 정보로 key-value 한 줄 생성."""
    if not val_str.endswith(';'):
        val_str += ';'

    key_part = base_indent + new_key
    if value_col is None:
        # 기본: 키 뒤 4칸
        return f"{key_part}    {val_str}"
    else:
        if len(key_part) >= value_col:
            return key_part + ' ' + val_str
        spaces = ' ' * (value_col - len(key_part))
        return key_part + spaces + val_str

def add_key_value_line_in_block(
    content: str,
    parent_block: str,
    new_key: str,
    new_value: Any,
) -> str:
    """
    parent_block 블록 안에 'new_key    new_value;' 추가하되,
    바로 윗줄의 값 시작 컬럼에 맞춰 정렬.
    """
    content = content.expandtabs(4)
    lines = content.split('\n')

    br = find_block_range(content, parent_block)
    if br is None:
        return add_key_value_line_global(content, new_key, str(new_value))

    start, end = br
    insert_idx = end  # 닫는 } 바로 위

    # parent_block 들여쓰기 기준 (블록 안 키 기본 들여쓰기)
    m = re.match(r'^(\s*)', lines[start])
    base_indent = (m.group(1) if m else '') + '    '

    val_str = str(new_value).strip()
    if not val_str.endswith(';'):
        val_str += ';'

    # 바로 위에서 값 컬럼 탐색
    value_col = None
    for i in range(insert_idx - 1, start, -1):
        col = detect_value_column(lines[i])
        if col is not None:
            value_col = col
            break

    if value_col is None:
        # 기준 줄을 못 찾으면 그냥 4칸 간격
        new_line = f"{base_indent}{new_key}    {val_str}"
    else:
        # 키 부분 먼저 만들고, 값 시작 컬럼에 맞춰 공백 채움
        key_part = base_indent + new_key
        if len(key_part) >= value_col:
            # 키가 너무 길면 한 칸만 띄움
            new_line = key_part + ' ' + val_str
        else:
            spaces = ' ' * (value_col - len(key_part))
            new_line = key_part + spaces + val_str

    lines.insert(insert_idx, new_line)
    return '\n'.join(lines) + '\n'

def add_block_in_block(
    content: str,
    parent_block: str,
    new_key: str,
    block_body: str | None = None,
) -> str:
    content = content.expandtabs(4)
    lines = content.split('\n')

    br = find_block_range(content, parent_block)
    if br is None:
        return add_block_global(content, new_key, block_body or '')

    start, end = br
    insert_idx = end  # 닫는 } 바로 위

    m = re.match(r'^(\s*)', lines[start])
    base_indent = (m.group(1) if m else '') + '    '
    inner_indent = base_indent + '    '

    body_lines: list[str] = []
    if block_body:
        for bline in block_body.split('\n'):
            if bline.strip() == '':
                body_lines.append('')
            else:
                body_lines.append(inner_indent + bline.rstrip())

    new_lines = [
        f"{base_indent}{new_key}",
        base_indent + "{",
        *body_lines,
        base_indent + "}",
    ]

    for offset, line in enumerate(new_lines):
        lines.insert(insert_idx + offset, line)

    return '\n'.join(lines) + '\n'

def add_key_value_line_global(content: str, new_key: str, new_value: str) -> str:
    content = content.expandtabs(4)
    lines = content.split('\n')

    val_str = new_value.strip()
    if not val_str.endswith(';'):
        val_str += ';'

    line = f"{new_key}    {val_str}"
    lines.append(line)
    return '\n'.join(lines) + '\n'

def add_block_global(content: str, new_key: str, block_body: str) -> str:
    content = content.expandtabs(4)
    lines = content.split('\n')

    base_indent = ''
    inner_indent = '    '

    body_lines: list[str] = []
    for bline in block_body.split('\n'):
        if bline.strip() == '':
            body_lines.append('')
        else:
            body_lines.append(inner_indent + bline.rstrip())

    new_lines = [
        f"{base_indent}{new_key}",
        base_indent + "{",
        *body_lines,
        base_indent + "}",
    ]
    lines.extend(new_lines)
    return '\n'.join(lines) + '\n'

def add_value(content: str, parent_block: str, target_block: str, key: str, value: Any | None = None) -> str:
    """
    - value=None  → target_block 내부 끝에 key { } 추가
    - value 존재 → target_block 내부 끝에 key    value; 추가
    """
    content = content.expandtabs(4)
    lines = content.split('\n')

    br_parent = find_block_range(lines, parent_block)
    if br_parent is None:
        return content  # parent_block 없으면 아무 것도 안 함

    # parent 범위 내에서 target_block 찾기
    sub_lines = lines[br_parent[0]:br_parent[1] + 1]
    br_target = find_block_range(sub_lines, target_block)
    if br_target is None:
        return content  # target_block 못 찾으면 안 함

    # 실제 인덱스로 변환
    t_start = br_parent[0] + br_target[0]
    t_end = br_parent[0] + br_target[1]

    # target_block 들여쓰기
    m = re.match(r'^(\s*)', lines[t_start])
    base_indent = (m.group(1) if m else '') + '    '

    # 값 컬럼: target_block 내부에서 마지막 값 있는 줄 기준
    value_col = None
    for i in range(t_end - 1, t_start, -1):
        col = detect_value_column(lines[i])
        if col is not None:
            value_col = col
            break

    insert_idx = t_end  # 닫는 } 바로 위

    if value is None:
        # 블록 추가
        inner_indent = base_indent + '    '
        new_lines = [
            f"{base_indent}{key}",
            base_indent + "{",
            base_indent + "}",
        ]
        for off, l in enumerate(new_lines):
            lines.insert(insert_idx + off, l)
    else:
        # 값 한 줄 추가
        val_str = str(value).strip()
        new_line = build_key_value_line(base_indent, key, val_str, value_col)
        lines.insert(insert_idx, new_line)

    return '\n'.join(lines) + '\n'


def insert_value(
    content: str,
    parent_block: str,
    target_block: str,
    key: str,
    value: Any | None = None,
    before: str | None = None,
    after: str | None = None,
) -> str:
    """
    - 기본 동작: target_block 내부에서 기준 키(before/after) 위치를 찾아 그 위/아래에 삽입
    - value=None  → key { } 블록을 삽입
    - value 존재 → key    value; 한 줄을 삽입 (값 컬럼은 기준 줄 값 컬럼에 정렬)
    """
    assert not (before and after), "before와 after는 동시에 쓸 수 없습니다."

    content = content.expandtabs(4)
    lines = content.split('\n')

    br_parent = find_block_range(lines, parent_block)
    if br_parent is None:
        return content

    sub_lines = lines[br_parent[0]:br_parent[1] + 1]
    br_target = find_block_range(sub_lines, target_block)
    if br_target is None:
        return content

    t_start = br_parent[0] + br_target[0]
    t_end = br_parent[0] + br_target[1]

    # target_block 들여쓰기
    m = re.match(r'^(\s*)', lines[t_start])
    base_indent = (m.group(1) if m else '') + '    '

    # 기준이 되는 anchor 키 줄 찾기
    anchor_idx = None
    anchor_name = before or after
    if anchor_name:
        for i in range(t_start + 1, t_end):  # 블록 내부만
            if re.match(rf'^\s*{re.escape(anchor_name)}\b', lines[i].strip()):
                anchor_idx = i
                break

    # anchor를 못 찾았으면 add_value처럼 끝에 추가
    if anchor_idx is None:
        return add_value(content, parent_block, target_block, key, value)

    # 값 컬럼: anchor 줄 기준
    value_col = detect_value_column(lines[anchor_idx])

    # 실제 삽입 위치 계산
    if before:
        insert_idx = anchor_idx
    else:  # after
        insert_idx = anchor_idx + 1

    if value is None:
        # 블록 삽입
        inner_indent = base_indent + '    '
        new_lines = [
            f"{base_indent}{key}",
            base_indent + "{",
            base_indent + "}",
        ]
        for off, l in enumerate(new_lines):
            lines.insert(insert_idx + off, l)
    else:
        # 값 한 줄 삽입
        val_str = str(value).strip()
        new_line = build_key_value_line(base_indent, key, val_str, value_col)
        lines.insert(insert_idx, new_line)

    return '\n'.join(lines) + '\n'



# ===================== 예제 =====================

if __name__ == "__main__":
    original = """functions
{
    probes1
    {
        type            probes;
        field           p;
    }

    probes2
    {
        type            probes;
        field           T;
    }
}
"""

    print("=== 원본 ===")
    print(original)

    # 1) probes2 내부에서 type 위에 new_type probes; 삽입 (before="type")
    print("=== 1) insert_value(..., before='type') ===")
    t1 = insert_value(
        original,
        parent_block="functions",
        target_block="probes2",
        key="new_type",
        value="probes",
        before="type",
    )
    print(t1)

    # 2) probes2 내부에서 type 아래에 new_type2 probes; 삽입 (after="type")
    print("=== 2) insert_value(..., after='type') ===")
    t2 = insert_value(
        original,
        parent_block="functions",
        target_block="probes2",
        key="new_type2",
        value="probes",
        after="type",
    )
    print(t2)