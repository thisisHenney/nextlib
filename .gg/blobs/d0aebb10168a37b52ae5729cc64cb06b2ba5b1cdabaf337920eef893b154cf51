# api.py
from pathlib import Path
import re

from .parser import parse_cst
from .builder import build_ast
from .editor import FoamEditor
from .rewriter import Rewriter
from .formatter import format_value   # ê¸°ì¡´ formatter ìˆìœ¼ë©´ ì‚¬ìš©

class FoamDict:
    def __init__(self, path: str | Path = ''):
        self.path = Path(path)
        self.encoding = "utf-8"

        self.text = ''
        self.cst = None
        self.ast = None
        self.editor = None
        self.rewriter = None

        self._initialize()

    def _initialize(self):
        self.update()

    def update(self, path: str | Path = ''):
        if path:
            self.path = Path(path)

        if self.path.is_file():
            self.text = self.path.read_text(encoding="utf-8")
            self.cst = parse_cst(self.text)
            self.ast = build_ast(self.cst)
            self.editor = FoamEditor(self.ast)
            self.rewriter = Rewriter(self.text)

    def get(self, route=[], default=None):
        if not self.text:
            return None

        return self.editor.get(route, default=default)

    def set(
            self,
            route,
            value,
            *,
            create=True,
            before=None,
            after=None,
            list_style="multiline"
    ):
        """
        Set value at route.
        If create=True and key does not exist, insert it.
        """

        # -----------------------------------------
        # 1. key ì¡´ì¬ ì—¬ë¶€ í™•ì¸
        # -----------------------------------------
        try:
            entry = self._locate_cst_entry(route)
        except KeyError:
            entry = None

        # -----------------------------------------
        # 2. ì—†ê³  create=False â†’ ê¸°ì¡´ ë™ì‘
        # -----------------------------------------
        if entry is None:
            if not create:
                raise KeyError(f"Route not found: {route}")

            # -------------------------------------
            # 3. create=True â†’ insertë¡œ ì „í™˜
            # -------------------------------------
            parent_route = route[:-1]
            key = route[-1]

            self.insert(
                route=parent_route,
                key=key,
                value=value,
                before=before,
                after=after,
                list_style=list_style
            )
            return

        # -----------------------------------------
        # 3. key ì¡´ì¬ + before/after ì§€ì • â†’ ì¬ë°°ì¹˜
        # -----------------------------------------
        if entry is not None and (before is not None or after is not None):
            # ê¸°ì¡´ ì—”íŠ¸ë¦¬ ì œê±°
            self.delete(route, missing_ok=False)

            # ì›í•˜ëŠ” ìœ„ì¹˜ì— ì¬ì‚½ì… (before/after ì ìš©)
            parent_route = route[:-1]
            key = route[-1]
            self.insert(
                route=parent_route,
                key=key,
                value=value,
                before=before,
                after=after,
                list_style=list_style
            )
            return


        # -----------------------------------------
        # ê¸°ì¡´ key â†’ replace (FINAL)
        # -----------------------------------------
        entry = self._locate_cst_entry(route)
        cst_entry = entry.cst_entry

        text = self.text

        # key í† í° ì‹œì‘ ìœ„ì¹˜
        key_start = cst_entry.key_token.span.start

        # í•´ë‹¹ ì¤„ì˜ ì‹œì‘
        line_start = text.rfind("\n", 0, key_start) + 1

        # ê¸°ì¡´ indent ê·¸ëŒ€ë¡œ
        indent = text[line_start:key_start]

        key = route[-1]
        key_pad = f"{key:<16}"
        value_text = format_value(
            value,
            key=key,
            indent=indent,
            list_style=list_style
        )

        new_text = f"{indent}{key_pad}{value_text}"

        # ğŸ”¥ ë°˜ë“œì‹œ line_startë¶€í„° replace
        self.rewriter.replace(line_start, cst_entry.span.end, new_text)

    def _locate_cst_entry(self, route):
        """
        Locate CSTEntry for given route.
        route: ["3", "inlet", "type"]
        """
        if not route:
            raise KeyError("Empty route")

        # AST ê¸°ì¤€ìœ¼ë¡œ ë¨¼ì € íƒìƒ‰
        node = self.editor.get_node(route)

        if node is None:
            raise KeyError(f"Route not found: {route}")

        # nodeëŠ” ASTValue ë˜ëŠ” ASTDict
        # ë°˜ë“œì‹œ ASTEntryë¥¼ ê±°ì³ì•¼ replace ê°€ëŠ¥
        parent_route = route[:-1]
        key = route[-1]

        parent = self.editor.get_node(parent_route)

        if parent is None or not hasattr(parent, "entries"):
            raise KeyError(f"Parent route not found: {parent_route}")

        entry = parent.entries.get(key)

        if entry is None:
            raise KeyError(f"Key not found: {key}")

        if entry.cst_entry is None:
            # boundary named-dict ë“±: replace ë¶ˆê°€
            raise KeyError(
                f"Entry '{key}' has no CST entry (cannot replace directly)"
            )

        return entry

    def dumps(self):
        return self.rewriter.apply()

    def save(self, backup=True):
        # if backup:
        #     bak = self.path.with_suffix(self.path.suffix + ".bak")
        #     bak.write_text(self.text, encoding=self.encoding)

        new_text = self.dumps()
        self.path.write_text(new_text, encoding=self.encoding)
        self.text = new_text

    def insert(
            self,
            route,
            key,
            value,
            *,
            before=None,
            after=None,
            list_style="multiline"
    ):
        parent = self.editor.get_node(route)

        if parent is None or not hasattr(parent, "entries"):
            raise TypeError(f"Insert target is not a dict: {route}")

        if key in parent.entries:
            raise KeyError(f"Key already exists: {key}")

        if not hasattr(parent, "cst_node") or parent.cst_node is None:
            raise RuntimeError("Parent ASTDict has no CST node")

        cst_dict = parent.cst_node

        # -----------------------------------------
        # ê¸°ì¤€ entry ê²°ì •
        # -----------------------------------------
        ref_entry = None
        insert_after = True

        # ğŸ”¥ ëª…ì‹œì  first / last
        if before == "__first__":
            first_key = next(iter(parent.entries), None)
            if first_key:
                ref_entry = parent.entries[first_key]
                insert_after = False

        elif before == "__last__":
            last_key = next(reversed(parent.entries), None)
            if last_key:
                ref_entry = parent.entries[last_key]
                insert_after = False

        elif after == "__last__":
            last_key = next(reversed(parent.entries), None)
            if last_key:
                ref_entry = parent.entries[last_key]
                insert_after = True

        elif before:
            ref_entry = parent.entries.get(before)
            insert_after = False
            if ref_entry is None:
                raise KeyError(f"before key not found: {before}")

        elif after:
            ref_entry = parent.entries.get(after)
            insert_after = True
            if ref_entry is None:
                raise KeyError(f"after key not found: {after}")

        # -----------------------------------------
        # ë“¤ì—¬ì“°ê¸° ê³„ì‚°
        # -----------------------------------------
        if route == []:
            indent = ""
        else:
            indent = self._infer_indent(cst_dict)

        key_pad = f"{key:<16}"
        value_text = format_value(
            value,
            key=key,
            indent=indent,
            list_style=list_style
        )

        # -----------------------------------------
        # new entry text ìƒì„± (FIXED)
        # -----------------------------------------
        is_multiline_list = isinstance(value, (list, tuple)) and list_style == "multiline"

        if is_multiline_list:
            # ğŸ”¥ key ë‹¨ë… ì¤„ + ë‹¤ìŒ ì¤„ì— ê´„í˜¸
            body = (
                f"{indent}{key}\n"
                f"{value_text};\n"
            )
        else:
            body = f"{indent}{key_pad}{value_text};\n"

        # ë£¨íŠ¸ë©´ ìœ„/ì•„ë˜ ë¹ˆ ì¤„ë§Œ ì¶”ê°€ (í˜•íƒœì—ëŠ” ê´€ì—¬ âŒ)
        if route == []:
            new_entry_line = f"\n{body}\n"
        else:
            new_entry_line = body

        # -----------------------------------------
        # ì‚½ì… ìœ„ì¹˜ ê³„ì‚° (FIXED ORDER)
        # -----------------------------------------
        text = self.text

        # 1ï¸âƒ£ before="__first__"
        if before == "__first__" and parent.entries:
            first_entry = next(iter(parent.entries.values()))
            entry_start = (
                first_entry.cst_entry.span.start
                if first_entry.cst_entry
                else first_entry.value_node.cst_node.span.start
            )
            pos = text.rfind("\n", 0, entry_start) + 1

        # 2ï¸âƒ£ before / after íŠ¹ì • í‚¤
        elif ref_entry and ref_entry.cst_entry:
            span = ref_entry.cst_entry.span

            if insert_after:
                # ğŸ”¥ ì—”íŠ¸ë¦¬ ì „ì²´(ë©€í‹°ë¼ì¸ í¬í•¨) ë ë‹¤ìŒ ì¤„
                line_end = text.find("\n", span.end)
                if line_end == -1:
                    pos = span.end
                else:
                    pos = line_end + 1
            else:
                # before: í•´ë‹¹ ì—”íŠ¸ë¦¬ ì¤„ ì‹œì‘
                pos = text.rfind("\n", 0, span.start) + 1

        # 3ï¸âƒ£ ë¹ˆ dict
        elif not parent.entries:
            open_brace_pos = cst_dict.span.start
            line_end = text.find("\n", open_brace_pos)
            if line_end == -1:
                line_end = cst_dict.span.start + 1
            pos = line_end + 1

        # 4ï¸âƒ£ ë£¨íŠ¸ + footer (fallback)
        elif route == []:
            footer_pos = self._find_footer_pos(text)
            if footer_pos is not None:
                footer_line_start = text.rfind("\n", 0, footer_pos)
                pos = footer_line_start + 1 if footer_line_start != -1 else 0
            else:
                pos = len(text)

        # 5ï¸âƒ£ ê¸°ë³¸: ë§ˆì§€ë§‰
        else:
            close_brace_pos = cst_dict.span.end
            pos = text.rfind("\n", 0, close_brace_pos) + 1

        # -----------------------------------------
        # ì‹¤ì œ ì‚½ì… (ê°œí–‰ ë³´ì •)
        # -----------------------------------------
        self.rewriter.insert(pos, new_entry_line)

    def _infer_indent(self, cst_dict):
        text = self.text
        start = cst_dict.span.start
        line_start = text.rfind("\n", 0, start) + 1
        base_indent = text[line_start:start]

        # dict ë‚´ë¶€ëŠ” í•œ ë‹¨ê³„ ë” ë“¤ì—¬ì”€
        return base_indent + "    "

    def _find_footer_pos(self, text):
        """
        Find position just before footer comment like:
        // **************
        """
        for match in re.finditer(r"^\s*//\s*\*{5,}.*$", text, re.MULTILINE):
            # footer ì²« ì¤„ ì‹œì‘ ìœ„ì¹˜
            line_start = match.start()
            return line_start
        return None

    def remove(self, route, *, missing_ok=False):
        """
        Delete entry or dict at route.
        Examples:
            ["2", "inlet", "type"]  -> entry ì‚­ì œ
            ["2", "inlet"]          -> dict ì „ì²´ ì‚­ì œ
        """

        if not route:
            raise ValueError("Empty route")

        text = self.text

        # -----------------------------------------
        # 1. ë¶€ëª¨ ë° entry í™•ì¸
        # -----------------------------------------
        parent_route = route[:-1]
        key = route[-1]

        parent = self.editor.get_node(parent_route)

        if parent is None or not hasattr(parent, "entries"):
            if missing_ok:
                return
            raise KeyError(f"Parent route not found: {parent_route}")

        entry = parent.entries.get(key)

        if entry is None:
            if missing_ok:
                return
            raise KeyError(f"Key not found: {key}")

        # -----------------------------------------
        # 2. dict entry ì¸ì§€ íŒë‹¨
        # -----------------------------------------
        is_dict = hasattr(entry.value_node, "cst_node") and entry.value_node.cst_node

        # -----------------------------------------
        # 3. ì‚­ì œ ë²”ìœ„ ê³„ì‚°
        # -----------------------------------------
        if is_dict:
            # ğŸ”¥ dict ì „ì²´ ì‚­ì œ
            key_span = entry.cst_entry.span
            dict_span = entry.value_node.cst_node.span

            start = key_span.start
            end = dict_span.end

            # key ì¤„ ì‹œì‘
            line_start = text.rfind("\n", 0, start)
            if line_start == -1:
                line_start = 0
            else:
                line_start += 1

            # dict ë‹«í˜ ë‹¤ìŒ ì¤„
            line_end = text.find("\n", end)
            if line_end == -1:
                line_end = end
            else:
                line_end += 1

            self.rewriter.replace(line_start, line_end, "")

        else:
            # ğŸ”¥ ì¼ë°˜ entry ì‚­ì œ (í•œ ì¤„)
            cst_entry = entry.cst_entry
            start = cst_entry.span.start
            end = cst_entry.span.end

            line_start = text.rfind("\n", 0, start)
            if line_start == -1:
                line_start = 0
            else:
                line_start += 1

            line_end = text.find("\n", end)
            if line_end == -1:
                line_end = end
            else:
                line_end += 1

            self.rewriter.replace(line_start, line_end, "")



