import re
from typing import List, Optional, Tuple, Any


def get_key_names(content: str, parent_block: str = "") -> List[str]:
    """지정된 위치의 키 이름들 반환 (순서 보존)"""
    content = content.expandtabs(4)
    lines = content.split('\n')

    if not parent_block:
        return _get_top_level_keys_ordered(lines)

    p_start, p_end = _find_block_range_brace(lines, parent_block)
    if p_start is None:
        return []

    return _get_keys_in_block_ordered(lines, p_start, p_end)


def _get_keys_in_block_ordered(lines: list[str], start: int, end: int) -> List[str]:
    """블록 내 키들만 (순서 보존, 하위 키 제외)"""
    keys = []
    for i in range(start + 1, end):
        line_stripped = lines[i].strip()
        if line_stripped and re.match(r'^\w+\b', line_stripped) and not line_stripped.endswith(';'):
            key = re.match(r'^\w+\b', line_stripped).group(0)
            if key not in keys:
                keys.append(key)
    return keys

def _get_top_level_keys_ordered(lines: list[str]) -> List[str]:
    """최상위 키들 (순서 보존)"""
    keys = []
    brace_level = 0
    for line in lines:
        line_stripped = line.strip()
        if not line_stripped or line_stripped.startswith('//'):
            continue

        brace_level += line.count('{') + line.count('(')
        brace_level -= line.count('}') + line.count(')')

        if brace_level == 0 and re.match(r'^\s*(\w+)\b', line_stripped):
            key = re.match(r'^\s*(\w+)\b', line_stripped).group(1)
            if key not in keys:  # 중복 제거
                keys.append(key)
    return keys


def get_key_value(content: str, parent_block: str, target_key: str, sub_key: str = "") -> Any:
    """키의 값을 반환 - {} vs () 자동 판별"""
    content = content.expandtabs(4)
    lines = content.split('\n')

    if parent_block == "":
        if sub_key:  # target_key solid → ['header', 'thruster']
            target_start, target_end = _find_block_range_brace(lines, target_key)
            if target_start is not None:
                return _get_subkey_value_auto(lines, target_start, target_end, sub_key)
        return _parse_top_level_key_value_fixed(lines, target_key)

    # 기존 로직 유지...
    p_start, p_end = _find_block_range_brace(lines, parent_block)
    if p_start is None:
        return None

    if sub_key:
        t_start, t_end = _find_named_block_in_range(lines, p_start, p_end, target_key)
        if t_start is None:
            return None
        return _parse_tuple_value_in_line(lines[t_start:t_end], sub_key)
    else:
        return _parse_key_value_direct_fixed(lines, p_start, p_end, target_key)


def _get_subkey_value_auto(lines: list[str], block_start: int, block_end: int, sub_key: str) -> List[str]:
    """inline tuple 형식: solid (header thruster)"""
    for i in range(block_start + 1, block_end):
        line_stripped = lines[i].strip()
        if re.match(rf'^\s*{re.escape(sub_key)}\b', line_stripped):
            m = re.search(rf'{re.escape(sub_key)}\s*\(\s*([^)]+)\s*\)', line_stripped)
            if m:
                return re.split(r'\s+', m.group(1).strip())
    return []



def _parse_tuple_value_in_line(lines: list[str], sub_key: str) -> List[str]:
    """regions solid → ["header", "thruster"]"""
    for line in lines:
        line_stripped = line.strip()
        if re.match(rf'^\s*{re.escape(sub_key)}\b', line_stripped):
            m = re.search(r'\(\s*([^)]+)\s*\)', line_stripped)
            if m:
                return re.split(r'\s+', m.group(1).strip())
    return []


def _parse_top_level_key_value_fixed(lines: list[str], key: str) -> Any:
    """모든 형식 자동 판별 - 따옴표 토큰 포함"""
    # 1. 블록 처리
    start, end = _find_block_range_brace(lines, key)
    if start is not None:
        next_line = lines[start + 1].strip()
        if next_line.startswith('('):
            return _get_tuple_keys_top_level_fixed(lines, start, end)
        elif next_line.startswith('{'):
            return _get_dict_keys_in_block(lines, start, end)

    # 2. inline 형식 판별
    for i, line in enumerate(lines):
        if re.match(rf'^\s*{re.escape(key)}\b', line.strip()):
            return _parse_inline_by_format(line.strip(), key)

    return None


def _parse_inline_by_format(line: str, key: str) -> Any:
    """inline 토큰 추출"""
    # 배열: [0 1 -2 0 0 0 0];
    m_array = re.search(r'\[(.*?)\];', line)
    if m_array:
        return re.findall(r'"[^"]*"|\w+', m_array.group(1))

    # 튜플: key (value1 value2);
    m_tuple = re.search(rf'{re.escape(key)}\s*\(([^)]+)\)', line)
    if m_tuple:
        return re.findall(r'"[^"]*"|\w+', m_tuple.group(1))

    # 단순 값: key value;
    m_simple = re.search(rf'{re.escape(key)}\s+([^\s;]+)', line)
    if m_simple:
        return [m_simple.group(1)]

    # 스칼라: key 0;
    m_scalar = re.search(r'\s+([^;]+);', line)
    return m_scalar.group(1).strip() if m_scalar else None


def _get_tuple_keys_top_level_fixed(lines: list[str], start: int, end: int) -> List[str]:
    """() 블록 내 토큰들 - 따옴표 포함 토큰 전체 반환"""
    tokens = []
    for i in range(start + 1, end):
        line_stripped = lines[i].strip()
        if not line_stripped:
            continue

        # 토큰 추출: 단어, "따옴표문자열", 숫자 등
        token_matches = re.findall(r'"[^"]*"|\w+', line_stripped)
        for token in token_matches:
            if token not in tokens:
                tokens.append(token)
    return tokens

def _parse_key_value_direct_fixed(lines: list[str], p_start: int, p_end: int, key: str) -> Any:
    """inGroups, offset 등 직접 키 파싱"""
    for i in range(p_start, p_end):
        if re.match(rf'^\s*{re.escape(key)}\b', lines[i]):
            line = lines[i].strip()
            m = re.search(r'\(\s*([^)]+)\s*\)', line)
            if m:
                return re.split(r'\s+', m.group(1).strip())
    return None


# ============================================================================
# 핵심 구현 함수들 (완전 구현)
# ============================================================================

def _get_top_level_keys_all(lines: list[str]) -> List[str]:
    """최상위 레벨 모든 키 이름들 추출"""
    keys = []
    brace_level = 0
    for line in lines:
        line_stripped = line.strip()
        if not line_stripped or line_stripped.startswith('//'):
            continue

        brace_level += line.count('{') + line.count('(')
        brace_level -= line.count('}') + line.count(')')

        if brace_level == 0 and re.match(r'^\s*\w+\b', line_stripped):
            key_match = re.match(r'^\s*(\w+)\b', line_stripped)
            if key_match:
                keys.append(key_match.group(1))

    return list(set(keys))


def _get_keys_in_range_all(lines: list[str], start: int, end: int) -> List[str]:
    """범위 내 모든 키 이름들 추출"""
    keys = []
    for i in range(start + 1, end):
        line_stripped = lines[i].strip()
        if line_stripped and re.match(r'^\w+\b', line_stripped):
            key_match = re.match(r'^\w+\b', line_stripped)
            if key_match:
                keys.append(key_match.group(0))
    return list(set(keys))


def _find_block_range_brace(lines: list[str], block_name: str) -> Tuple[Optional[int], Optional[int]]:
    """name { ... } 또는 name ( ... ) 블록 범위"""
    n = len(lines)
    start = None
    for i, line in enumerate(lines):
        if re.match(rf'^\s*{re.escape(block_name)}\b', line.strip()):
            start = i
            break
    if start is None:
        return None, None

    i = start + 1
    brace_level = 0
    for j in range(i, n):
        brace_level += lines[j].count('{') + lines[j].count('(')
        brace_level -= lines[j].count('}') + lines[j].count(')')
        if brace_level == 0:
            return start, j
    return None, None


def _parse_top_level_key_value(lines: list[str], key: str) -> Any:
    """최상위 레벨 키 값 파싱 - {} vs () 자동 판별"""
    start, end = _find_block_range_brace(lines, key)

    if start is not None:
        # 블록이 있으면 구조 판별
        next_line = lines[start + 1].strip()
        if next_line.startswith('{'):
            # {} 블록: 딕셔너리 → 키 이름들 반환
            return _get_dict_keys_in_block(lines, start, end)
        elif next_line.startswith('('):
            # () 블록: 리스트/튜플 → 내부 키들 반환 (regions 등)
            return _get_tuple_keys_top_level(lines, start, end)

    # inline 키-값 처리
    for i, line in enumerate(lines):
        if re.match(rf'^\s*{re.escape(key)}\b', line.strip()):
            line_stripped = line.strip()
            m = re.search(r'\s+([^;]+);', line_stripped)
            if m:
                return m.group(1).strip()

    return None

def _get_dict_keys_in_block(lines: list[str], start: int, end: int) -> List[str]:
    """{} 블록 내 키들 (header, thruster 등)"""
    keys = []
    for i in range(start + 1, end):
        line_stripped = lines[i].strip()
        if re.match(r'^\w+\b', line_stripped) and not line_stripped.endswith(';'):
            key = re.match(r'^\w+\b', line_stripped).group(0)
            if key not in keys:
                keys.append(key)
    return keys


def _parse_libs_list_top_level(lines: list[str], start: int, end: int) -> List[str]:
    """libs 블록 내부 리스트 파싱 (따옴표 포함)"""
    libs = []
    for i in range(start + 1, end):
        line = lines[i].rstrip()
        m = re.match(r'^\s*"([^"]*)"', line)
        if m:
            libs.append(f'"{m.group(1)}"')
    return libs


def _get_tuple_keys_top_level(lines: list[str], start: int, end: int) -> List[str]:
    """() 블록 내 키들 (regions ( fluid () ... ) → ['fluid'])"""
    keys = []
    for i in range(start + 1, end):
        line_stripped = lines[i].strip()
        if re.match(r'^\w+\b', line_stripped):
            key_match = re.match(r'^\w+\b', line_stripped)
            if key_match:
                keys.append(key_match.group(0))
    return keys


def _parse_key_value_direct(lines: list[str], p_start: int, p_end: int, key: str) -> Any:
    """직접 키 값 파싱 (inGroups, offset 등)"""
    for i in range(p_start, p_end):
        if re.match(rf'^\s*{re.escape(key)}\b', lines[i]):
            line = lines[i].strip()
            m = re.search(r'\(\s*([^)]+)\)\s*;?', line)
            if m:
                return re.findall(r'[\w.-]+', m.group(1))
    return None


def _parse_key_value_in_block(lines: list[str], t_start: int, t_end: int, sub_key: str) -> List[str]:
    """서브 블록 내 키 값 파싱"""
    for i in range(t_start + 1, t_end):
        if re.match(rf'^\s*{re.escape(sub_key)}\b', lines[i]):
            line = lines[i].strip()
            m = re.search(r'\(\s*([^)]+)\)\s*;?', line)
            if m:
                return re.findall(r'[\w.-]+', m.group(1))
    return []


def _find_named_block_in_range(lines: list[str], start: int, end: int, name: str) -> Tuple[
    Optional[int], Optional[int]]:
    """범위 내 named { ... } 블록 찾기"""
    block_start = None
    for i in range(start, end + 1):
        if lines[i].strip() == name:
            block_start = i
            break
    if block_start is None:
        return None, None

    i = block_start + 1
    brace_level = 0
    for j in range(i, end + 1):
        brace_level += lines[j].count('{')
        brace_level -= lines[j].count('}')
        if brace_level == 0:
            return block_start, j
    return None, None


def _find_number_parent(lines: list[str], number: str) -> Tuple[Optional[int], Optional[int]]:
    """숫자 boundary 형식"""
    n = len(lines)
    for i, line in enumerate(lines):
        if line.strip() == number:
            for j in range(i + 1, n):
                if lines[j].strip().startswith('('):
                    start = j
                    brace_level = 0
                    for k in range(start, n):
                        brace_level += lines[k].count('(')
                        brace_level -= lines[k].count(')')
                        if brace_level == 0:
                            return start, k
    return None, None


# ============================================================================
# 테스트
# ============================================================================

if __name__ == "__main__":
    sample = """
libs
(
    "libmyLiquids8.so"
);

application     twoSprayChtMultiRegionCentralFoam;

startFrom       startTime;

startTime       0;

endTime         0.02;

deltaT          1e-06;

functions
{
    probes1
    {
        type probes;
    }
    probes2
    {
        type probes;
    }
}

newdata
(
    fluid (fluid)
    solid (header thruster)
);
"""

    print("=== get_key_names 테스트 ===")
    print("최상위:", get_key_names(sample, ""))
    print("functions 내:", get_key_names(sample, "functions"))

    print("\n=== get_key_value 테스트 ===")
    print('libs:', get_key_value(sample, "", "libs"))
    print("regions:", get_key_value(sample, "", "newdata", ""))
    print("regions solid:", get_key_value(sample, "", "newdata", "solid"))
